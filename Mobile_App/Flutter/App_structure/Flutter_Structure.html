<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Complete Flutter App Structure Explained</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f9fbfd;
    max-width: 900px;
    margin: 2rem auto;
    padding: 0 1.5rem;
    color: #2c3e50;
    line-height: 1.6;
  }
  h1, h2, h3 {
    color: #1a2732;
    border-bottom: 3px solid #3498db;
    padding-bottom: 0.3rem;
    margin-bottom: 1rem;
    font-weight: 700;
  }
  p {
    font-size: 1.1rem;
    margin-bottom: 1.2rem;
  }
  strong {
    color: #34495e;
  }
  code {
    background-color: #ecf0f1;
    color: #2d3436;
    padding: 0.3rem 0.6rem;
    border-radius: 5px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.95rem;
  }
  pre {
    background-color: #ecf0f1;
    padding: 1.2rem 1.5rem;
    border-radius: 10px;
    overflow-x: auto;
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.95rem;
    margin-bottom: 2rem;
    box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.1);
    line-height: 1.4;
  }
  .highlight {
    background-color: #eaf2f8;
    border-left: 5px solid #3498db;
    padding: 1.2rem 1.5rem;
    border-radius: 8px;
    margin: 2rem 0;
    box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
  }
  .highlight p {
    margin: 0 0 0.8rem 0;
    font-weight: 600;
    font-size: 1.1rem;
  }
  .highlight ul {
    margin: 0;
    padding-left: 1.2rem;
    list-style-type: disc;
    font-size: 1rem;
  }
  a {
    color: #2980b9;
    font-weight: 600;
    text-decoration: none;
  }
  a:hover, a:focus {
    text-decoration: underline;
    outline: none;
  }
</style>
</head>
<body>

  <h1>Complete Flutter App Structure Explained</h1>

  <p>Flutter apps are built using the <strong>Dart programming language</strong> and revolve around the concept of <code>Widgets</code>, which compose the user interface. Below is a full basic Flutter app structure with detailed explanation of each part, <em>why</em> it exists, and <em>how</em> it works.</p>

  <h2>Full Flutter App Code</h2>
  <pre><code>import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo App',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: HomePage(),
    );
  }
}

class HomePage extends StatefulWidget {
  @override
  _HomePageState createState() =&gt; _HomePageState();
}

class _HomePageState extends State&lt;HomePage&gt; {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Home Page'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            Text(
              'You have pressed the button this many times:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: Icon(Icons.add),
      ),
    );
  }
}
</code></pre>

  <div class="highlight">
    <p><strong>Breaking down the code:</strong></p>
    <ul>
      <li><code>import 'package:flutter/material.dart';</code> imports Flutter's material design widgets and tools. This package provides a rich set of pre-built UI components.</li>
      <li><code>void main() { runApp(MyApp()); }</code> is the entry point of every Flutter app. <code>runApp()</code> attaches the widget tree to the screen. Here, <code>MyApp</code> is the root widget.</li>
      <li><code>MyApp</code> extends <code>StatelessWidget</code> because this widget itself does not hold any mutable state. It builds a <code>MaterialApp</code>, which sets up basic app-level configurations:</li>
      <ul>
        <li><code>title</code> is the app title used in task switchers.</li>
        <li><code>theme</code> sets global app styling like colors.</li>
        <li><code>home</code> specifies the default screen widget, here <code>HomePage</code>.</li>
      </ul>
      <li><code>HomePage</code> is a <code>StatefulWidget</code> because it holds mutable state: the counter value.</li>
      <li>The <code>_HomePageState</code> class holds the state for <code>HomePage</code>:</li>
      <ul>
        <li>It declares a private integer <code>_counter</code> initialized to 0.</li>
        <li><code>_incrementCounter()</code> updates the counter and calls <code>setState()</code> to tell Flutter to redraw UI reflecting the new state.</li>
      </ul>
      <li>The <code>build()</code> method returns the UI for this screen:</li>
      <ul>
        <li><code>Scaffold</code> provides a default app layout with an <code>AppBar</code>, <code>body</code>, and <code>FloatingActionButton</code>.</li>
        <li><code>body</code> contains a <code>Center</code> widget with a vertical <code>Column</code> that shows descriptive text and the current counter.</li>
        <li>The floating action button calls <code>_incrementCounter</code> when pressed to increase the counter.</li>
      </ul>
    </ul>
  </div>

  <h2>Why these parts?    <a href="Structure_Explained.htm" target="_blank">See Full Guide</a>  </h2>
  <p><strong>StatelessWidget vs StatefulWidget:</strong> StatelessWidgets are immutable and used when UI doesn't change dynamically. StatefulWidgets can rebuild with updated data or user interaction.</p>
  <p><strong>MaterialApp:</strong> Provides fundamental app structure, theming, navigation support, localization, and more out of the box.</p>
  <p><strong>Scaffold:</strong> Gives you basic app visual structure with app bars, drawers, floating buttons, and body content, saving time to build these common parts manually.</p>
  <p><strong>setState:</strong> Notifies Flutter that the internal state changed so the framework knows to rebuild widgets with new data, refreshing the UI.</p>

  <h2>How does Flutter render this?</h2>
  <p>Flutter uses a reactive programming model. When <code>setState()</code> is called, Flutter schedules a rebuild of widgets below that widget in the tree, updating what is rendered on screen. Widgets themselves are lightweight and immutable; the framework efficiently manages rendering differences.</p>

  <h2>Summary</h2>
  <ul>
    <li>Your app starts with <code>main()</code>, which calls <code>runApp()</code>.</li>
    <li>The root widget, often a <code>MaterialApp</code>, sets theme, routes, and the initial screen.</li>
    <li>Screens/widgets can be stateful or stateless depending on need.</li>
    <li>UI is composed using nested widgets.</li>
    <li>State changes are managed via <code>setState()</code> to update UI reactively.</li>
  </ul>

  <h2>Further Reading & Official References</h2>
  <ul>
    <li><a href="https://flutter.dev/docs/get-started/flutter-for/android-devs#your-first-flutter-app" target="_blank" rel="noopener noreferrer">Your first Flutter app (official guide)</a></li>
    <li><a href="https://flutter.dev/docs/development/ui/widgets-intro" target="_blank" rel="noopener noreferrer">Introduction to widgets</a></li>
    <li><a href="https://flutter.dev/docs/development/ui/interactive" target="_blank" rel="noopener noreferrer">Managing state in Flutter</a></li>
    <li><a href="https://api.flutter.dev/flutter/material/MaterialApp-class.html" target="_blank" rel="noopener noreferrer">MaterialApp API docs</a></li>
    <li><a href="https://api.flutter.dev/flutter/material/Scaffold-class.html" target="_blank" rel="noopener noreferrer">Scaffold API docs</a></li>
  </ul>

</body>
</html>
